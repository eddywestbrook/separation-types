Require Import SepTypes.Functor SepTypes.OrderedType SepTypes.OFuns
        SepTypes.PChain SepTypes.Tree.

(* Some weird notations. *)
Notation "'ϕ'" := unfoldCompose (at level 65) : mem_scope.
Notation "'ψ'" := foldCompose (at level 65) : mem_scope.
Notation "a '×' b" := (ProductF a b) (at level 65) : mem_scope.
Notation "'|' x '|'" := (ConstantF x) (at level 65) : mem_scope.
Notation "'ϒ' x" := (TreeF x) (at level 65) : mem_scope.

Open Scope mem_scope.

(** The recursive type for memory stores. *)
Section mem.
  Context Z `{OType Z}.

  Definition permF : TypeF := PERF × PreOrderF.

  Definition memF : TypeF := |Z| × ϒ permF.

  Definition MemDiag : nat -> Type := type_n memF.
  Definition Mem := PChain (type_n memF).

  Definition MemPERDiag f `{PDiagram f} := typeSequenceMap f PERF.
  Definition MemPER f `{PDiagram f} := PChain (MemPERDiag f).

  Definition MemPreOrderDiag f `{PDiagram f} := typeSequenceMap f PreOrderF.
  Definition MemPreOrder f `{PDiagram f} := PChain (MemPreOrderDiag f).

  Definition Perm f `{PDiagram f} := (MemPER f * MemPreOrder f)%type.

  (* These are a bit slow to typecheck... *)
  (* But at least they verify that the UnfoldF instance generated by
     typeclass resolution is the type we expect. *)
  (* Definition unfoldSanityCheck *)
  (*   : Mem -o> Z * Tree (Perm (type_n memF)) := ϕ memF. *)
  (* Definition foldSanityCheck *)
  (*   : Z * Tree (Perm (type_n memF)) -o> Mem := ψ memF. *)

  (** To build a Mem, it suffices to build an element of
      [Z * Tree (Perm (type_n memF))] and then apply the fold
      operation. *)

  (* Turn a chain of PERs to a PER on PChains. *)
  Definition memPEREq {f} `{PDiagram f} (per : MemPER f)
    : relation (PChain f) :=
    fun c1 c2 => forall n, proj1_sig (chain per n) (chain c1 n) (chain c2 n).

  (* Turn a chain of preorders to a preorder on PChains. *)
  Definition memPreOrderEq {f} `{PDiagram f} (po : MemPreOrder f)
    : relation (PChain f) :=
    fun c1 c2 => forall n, proj1_sig (chain po n) (chain c1 n) (chain c2 n).

  (* Turn a permission into a PER on PChains. *)
  Definition permEq {f} `{PDiagram f} (p : Perm f) : relation (PChain f) :=
    memPEREq (fst p).

  (* Turn a permission into a preorder on PChains. *)
  Definition permUpd {f} `{PDiagram f} (p : Perm f) : relation (PChain f) :=
    memPreOrderEq (snd p).

  (* A generic contramap operation for relations. *)
  Definition contramap_rel {A B} `{OType A} `{OType B} (f : A -o> B)
             (R : relation B) : relation A :=
    fun x y => R (f @@ x) (f @@ y).

  
  (* Here we assume that the diagram starts at F unit rather than
     unit. This makes the fixpoint functions much simpler. So, given a
     relation on F unit, we can construct a relation on chains of the
     diagram F unit, F (F unit), ... and then extend it to the full
     diagram by prepending the trivial relation on unit to the
     front. *)
  
  Program Fixpoint mkPER_f {f} `{PDiagram f}
          (R0 : relation (f 0)) n : relation (f n) :=
    match n with
    | O => R0
    | S n' => contramap_rel (proj n') (mkPER_f R0 n')
    end.

  Program Fixpoint mkPreOrder_f {f} `{PDiagram f}
          (R0 : relation (f 0)) n : relation (f n) :=
    match n with
    | O => R0
    | S n' => contramap_rel (proj n') (mkPreOrder_f R0 n')
    end.

  Lemma exist_inv {A : Type} `{OType A} {P : A -> Prop}
        (a b : {x : A | P x}) :
    a =o= b -> proj1_sig a =o= proj1_sig b.
  Proof. firstorder. Qed.

  Lemma exist_oeq {A : Type} `{OType A} {P : A -> Prop}
        (a b : {x : A | P x}) :
    proj1_sig a =o= proj1_sig b -> a =o= b.
  Proof. firstorder. Qed.

  Instance Proper_mkPER_f {f} `{PDiagram f} R n :
    Proper (oeq ==> oeq ==> oleq) R ->
    Proper (oeq ==> oeq ==> oleq) (mkPER_f R n).
  Proof.
    intros Hprop x y Heq1 z w Heq2.
    induction n; simpl in *.
    - rewrite Heq1, Heq2. reflexivity.
    - unfold contramap_rel. apply IHn.
      rewrite Heq1; reflexivity.
      rewrite Heq2; reflexivity.
  Qed.

  Instance Transitive_mkPER_f {f} `{PDiagram f} R n :
    Transitive  R ->
    Transitive (mkPER_f R n).
  Proof.
    intros HTrans x y z Hxy Hyz.
    induction n; simpl in *.
    - etransitivity; eauto.
    - eapply IHn; eauto.
  Qed.

  (* Build a chain of PER relations from a single one. *)
  Program Definition mkPER {f} `{PDiagram f} (R : relation (f 0))
          {per : Per R} : MemPER f :=
    {| chain := mkPER_f R |}.
  Next Obligation.
    rename x into n.
    constructor.
    - intros x y Heq1 z w Heq2 Hr.
      induction n; auto.
      + destruct per. rewrite <- Heq1, <- Heq2; auto.
      + eapply IHn; eauto. rewrite Heq1; reflexivity.
        rewrite Heq2; reflexivity.
    - intros x y Hr.
      induction n; auto; simpl in *.
      + destruct per; auto.
      + apply IHn. auto.
    - intros x y z Hzy Hyz.
      induction n; auto.
      destruct per; eapply Transitive_Per; eauto.
      eapply IHn; eauto.
  Qed.

  (* Here we need "pseudo-embed" functions to complete the proof. *)
  Next Obligation.
    simpl.
    apply exist_oeq; simpl.
    split.
    - intros x y Hr.
      apply t_step.
      assert (exists x1, proj n @@ x1 =o= x).
      { admit. }
      assert (exists x2, proj n @@ x2 =o= y).
      { admit. }
      destruct H1 as [x1 ?], H2 as [x2 ?].
      exists x1, x2. split; auto. split; auto.
      unfold contramap_rel.
      destruct per.
      rewrite H1, H2; auto.
    - intros x y Hclos.
      induction Hclos.
      + destruct H1 as (x1 & x2 & ? & ? & ?).
        unfold contramap_rel in H3.
        destruct per.
        rewrite <- H1, <- H2; auto.
      + destruct per; etransitivity; eauto.
  Admitted.

  (* Build a chain of preorder relations from a single one. *)
  Program Definition mkPreOrder {f} `{PDiagram f} (R : relation (f 0))
          {po : Preorder R} : MemPreOrder f :=
    {| chain := mkPreOrder_f R |}.
  Next Obligation.
    rename x into n.
    constructor.
    - intros x y Heq1 z w Heq2 Hr.
      induction n; auto.
      + destruct po. rewrite <- Heq1, <- Heq2; auto.
      + eapply IHn; eauto. rewrite Heq1; reflexivity.
        rewrite Heq2; reflexivity.
    - constructor.
      + intros x. induction n; simpl; auto.
        destruct po as [_ []]; auto.
        apply IHn.
      + intros x y z Hxy Hyz. induction n; auto.
        destruct po as [_ []].
        eapply PreOrder_Transitive; eauto.
        eapply IHn; eauto.
  Qed.

  Next Obligation. Admitted.

End mem.
